/**
 * @typedef {Object} DumpItem
 * @property {string} ota_id
 * @property {string} fw_version
 * @property {string} webos_version
 * @property {string} webos_codename
 * @property {number} dejavuln
 * @property {number} asm
 * @property {number} wta
 * @property {number} crashd
 * @property {number} rootmytv
 * @property {number} downgradable
 * @property {string} build_date
 */

/**
 * @type {DumpItem[]}
 */
import dump from "./data/fw-updates.json" assert {type: "json"};
import semver from "semver";
import {groupBy} from "lodash-es";
import * as fs from "node:fs";

/**
 * @type {Record<string, DumpItem[]>}
 */
let grouped = groupBy(dump, "ota_id");

/**
 * @type {Record<string, Record<string, DeviceExploitAvailabilitiesData>>}
 */
let output = {};

/**
 *
 * @param item {DumpItem} Dump item to populate
 * @param availabilities {DeviceExploitAvailabilitiesData} Firmware item to populate
 * @param key {'dejavuln'|'asm'|'wta'|'crashd'|'rootmytv'} Name of the exploit
 * @param webosSatisfies {string} webOS version that satisfies the exploit
 * @return {boolean}
 */
function populateExploitAvailability(item, availabilities, key, webosSatisfies) {
  if (!semver.satisfies(item.webos_version, webosSatisfies, {loose: true, includePrerelease: true})) {
    return false;
  }
  if (!availabilities[key]) {
    availabilities[key] = {};
  }
  if (item[key]) {
    if (!availabilities[key].latest || item.fw_version > availabilities[key].latest.version) {
      availabilities[key].latest = {
        version: item.fw_version,
        release: item.webos_version,
        codename: item.webos_codename,
      };
      return true;
    }
  } else {
    if (!availabilities[key].patched || item.fw_version < availabilities[key].patched.version) {
      availabilities[key].patched = {
        version: item.fw_version,
        release: item.webos_version,
        codename: item.webos_codename,
      };
    }
  }
  return false;
}

/**
 * Compare two OTA IDs by their generation
 * @param a {string}
 * @param b {string}
 * @returns {number}
 */
function compareOTAID(a, b) {
  /**
   * @param otaId {string}
   * @return {{typ: string, cls: string, gen: number, ser: string, reg: string}}
   */
  function parseOTAID(otaId) {
    let match = otaId.match(/HE_(?<typ>\w{3})_(?<cls>\w)(?<gen>\w{2})(?<ser>\w)_(?<reg>\w{8})/);
    return {
      typ: match.groups.typ,
      cls: match.groups.cls,
      gen: match.groups.gen === "T1" ? 14 : parseInt(match.groups.gen),
      ser: match.groups.ser,
      reg: match.groups.reg,
    };
  }

  const parsedA = parseOTAID(a);
  const parsedB = parseOTAID(b);
  if (parsedA.gen !== parsedB.gen) {
    return parsedA.gen - parsedB.gen;
  }
  if (parsedA.cls !== parsedB.cls) {
    return parsedA.cls.localeCompare(parsedB.cls);
  }
  if (parsedA.typ !== parsedB.typ) {
    return parsedA.typ.localeCompare(parsedB.typ);
  }
  if (parsedA.ser !== parsedB.ser) {
    return parsedA.ser.localeCompare(parsedB.ser);
  }
  return parsedA.reg.localeCompare(parsedB.reg);
}

/**
 *
 * @param availabilities {DeviceExploitAvailabilitiesData}
 * @param items {DumpItem[]}
 * @returns {boolean}
 */
function populateAvailabilities(availabilities, items) {
  let hasExploit = false;
  for (const item of items) {
    // Skip abnormal firmware versions
    if (semver.major(item.fw_version, true) >= 99) {
      continue;
    }
    if (semver.satisfies(item.webos_version, "<4", {loose: true, includePrerelease: true})) {
      availabilities['nvm'] = {};
      hasExploit = true;
    }
    hasExploit |= populateExploitAvailability(item, availabilities, "rootmytv", "3 - 7");
    hasExploit |= populateExploitAvailability(item, availabilities, "crashd", "4 - 8");
    hasExploit |= populateExploitAvailability(item, availabilities, "wta", "5 - 8");
    hasExploit |= populateExploitAvailability(item, availabilities, "asm", "4 - 8");
    hasExploit |= populateExploitAvailability(item, availabilities, "dejavuln", "3.5 - 8");
  }
  return hasExploit;
}

for (const [ota_id, items] of Object.entries(grouped).sort(([a,], [b,]) => compareOTAID(a, b))) {
  // Sort ascending by firmware version
  items.sort((a, b) => a.fw_version.localeCompare(b.fw_version, 'en'));
  /** @type {Record<string, DumpItem[]>} */
  const groupedByCodename = groupBy(items, item => item.webos_codename.split('-', 1)[0]);
  const codenames = Object.keys(groupedByCodename);
  let hasExploit = false;
  /** @type {Record<string, DeviceExploitAvailabilitiesData>} */
  let value = {};
  for (const codename of codenames) {
    /** @type {DeviceExploitAvailabilitiesData} */
    const availabilities = {};
    if (populateAvailabilities(availabilities, groupedByCodename[codename])) {
      value[codename] = availabilities;
      hasExploit = true;
    }
  }
  if (!hasExploit) {
    console.warn(`No exploits found for ${ota_id}`);
    continue;
  }
  output[ota_id] = value;
}

// language=JavaScript
const header = '/** @type {Record<string, Record<string, DeviceExploitAvailabilitiesData>>} */\nexport default ';
fs.writeFileSync("src/exploits.gen.js", header + JSON.stringify(output, null, 2));