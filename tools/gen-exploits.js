/**
 * @typedef {Object} DumpItem
 * @property {string} ota_id
 * @property {string} fw_version
 * @property {string} webos_version
 * @property {string} webos_codename
 * @property {number} dejavuln
 * @property {number} wta
 * @property {number} crashd
 * @property {number} rootmytv
 * @property {string} build_date
 */

/**
 * @type {DumpItem[]}
 */
import dump from "./data/fw-updates.json" assert {type: "json"};
import semver from "semver";
import {groupBy} from "lodash-es";
import * as fs from "node:fs";

/**
 * @type {Record<string, DumpItem[]>}
 */
let grouped = groupBy(dump, "ota_id");

/**
 * @type {Record<string, DeviceExploitAvailabilities>}
 */
let output = {};

/**
 *
 * @param item {DumpItem} Dump item to populate
 * @param availabilities {DeviceExploitAvailabilities} Firmware item to populate
 * @param key {'dejavuln'|'wta'|'crashd'|'rootmytv'} Name of the exploit
 * @param webosSatisfies {string} webOS version that satisfies the exploit
 */
function populateExploitAvailability(item, availabilities, key, webosSatisfies) {
  if (!semver.satisfies(item.webos_version, webosSatisfies, {loose: true, includePrerelease: true})) {
    return;
  }
  if (!availabilities[key]) {
    availabilities[key] = {};
  }
  if (item[key]) {
    if (!availabilities[key].latest || item.fw_version > availabilities[key].latest.version) {
      availabilities[key].latest = {
        version: item.fw_version,
        release: item.webos_version,
        codename: item.webos_codename,
      };
    }
  } else {
    if (!availabilities[key].patched || item.fw_version < availabilities[key].patched.version) {
      availabilities[key].patched = {
        version: item.fw_version,
        release: item.webos_version,
        codename: item.webos_codename,
      };
    }
  }
}

/**
 * Compare two OTA IDs by their generation
 * @param a {string}
 * @param b {string}
 * @returns {number}
 */
function compareOTAID(a, b) {
  /**
   * @param otaId {string}
   * @return {{typ: string, gen: number, ser: string, reg: string}}
   */
  function parseOTAID(otaId) {
    let match = otaId.match(/HE_(?<typ>\w{3})_\w(?<gen>\w{2})(?<ser>\w)_(?<reg>\w{8})/);
    return {
      typ: match.groups.typ,
      gen: match.groups.gen === "T1" ? 14 : parseInt(match.groups.gen),
      ser: match.groups.ser,
      reg: match.groups.reg,
    };
  }

  const parsedA = parseOTAID(a);
  const parsedB = parseOTAID(b);
  if (parsedA.gen !== parsedB.gen) {
    return parsedA.gen - parsedB.gen;
  }
  if (parsedA.typ !== parsedB.typ) {
    return parsedA.typ.localeCompare(parsedB.typ);
  }
  if (parsedA.ser !== parsedB.ser) {
    return parsedA.ser.localeCompare(parsedB.ser);
  }
  return parsedA.reg.localeCompare(parsedB.reg);
}

for (const [ota_id, items] of Object.entries(grouped).sort(([a,], [b,]) => compareOTAID(a, b))) {
  // Sort ascending by firmware version
  items.sort((a, b) => semver.compare(a.fw_version, b.fw_version, true));
  /** @type {DeviceExploitAvailabilities} */
  let availabilities = {};
  for (const item of items) {
    // Skip abnormal firmware versions
    if (semver.major(item.fw_version, true) >= 99) {
      continue;
    }
    if (semver.satisfies(item.webos_version, "<4", {loose: true, includePrerelease: true})) {
      availabilities['nvm'] = {};
    }
    populateExploitAvailability(item, availabilities, "rootmytv", "3 - 7");
    populateExploitAvailability(item, availabilities, "crashd", "4 - 8");
    populateExploitAvailability(item, availabilities, "wta", "5 - 8");
    populateExploitAvailability(item, availabilities, "dejavuln", "3.5 - 8");
  }
  output[ota_id] = availabilities;
}

// language=JavaScript
const header = '/** @type {Record<string, DeviceExploitAvailabilities>} */\nexport default ';
fs.writeFileSync("src/exploits.gen.js", header + JSON.stringify(output, null, 2));